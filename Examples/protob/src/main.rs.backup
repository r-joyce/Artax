extern crate protobuf;
extern crate snap;
extern crate csv;

use std::error::Error;
use std::io;
use std::process;

#[macro_use]

// use std::error::Error;
// use std::io;
// use std::io::{self, BufRead};

// mod protos;
// use protos::message;
// use protobuf::Message;

// #[test]
// fn derp() {
// }

// fn main() {
// 	// Get input
// 	print!("Encode: ");
// 	io::Write::flush(&mut io::stdout()).expect("flush failed!");

// 	let reader = io::stdin();
// 	let nums: Vec<i32> =
// 		reader.lock()
// 			.lines().next().unwrap().unwrap()
// 			.trim().split(' ')
//         	.map(|s| s.parse().unwrap())
//         	.collect();
//     let length = nums.len();
	
// 	// Show raw input
// 	println!("Plain: {:?}", nums);

// 	// Encode
// 	let mut message = message::Message::new();
// 	message.set_mz(nums);

// 	// Compress
// 	let results = message.write_to_bytes();
// 	// let comp = lzf::compress(&results.unwrap());
// 	// println!("Encoded: {:?}", comp);

// 	// Decompress
// 	// let decomp = lzf::decompress(&comp.unwrap(), length);

// 	// Show encoded message
// 	// println!("Decoded: {:?}", decomp);
// }

#[derive(Debug,Deserialize)]
struct Record {
    tic: f32,
    time: u32,
}

fn encode_data() -> Result<(), Box<Error>> {
	Ok(())
}

fn get_input() -> Result<(), Box<Error>> {
	// Build the CSV reader and iterate over each record.
    let mut reader = csv::Reader::from_reader(io::stdin());
    for result in reader.deserialize() {
        // The iterator yields Result<StringRecord, Error>, so we check the
        // error here.
        let record: Record = result?;
        // let record = result?;
        // let () = record;
        // println!("{:?}", record);
    }
    if let Err(err) = encode_data() {
    	println!("[!] Error encoding and compressing data:{}", err);
    	process::exit(1);
    }
    Ok(())
}

fn main() {
    if let Err(err) = get_input() {
        println!("[!] Error processing file: {}", err);
        process::exit(1);
    }
}